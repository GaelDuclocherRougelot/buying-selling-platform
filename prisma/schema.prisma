generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String         @id
  name                String
  email               String         @unique
  emailVerified       Boolean
  image               String?
  username            String?        @unique
  role                String         @default("user")
  deletedAt           DateTime?
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  displayUsername     String?
  stripeAccountId     String?        @unique
  stripeAccountStatus String?        @default("pending")
  accounts            Account[]
  buyerConversations  Conversation[] @relation("BuyerConversations")
  sellerConversations Conversation[] @relation("SellerConversations")
  favorites           Favorite[]
  loginLogs           LoginLog[]
  messages            Message[]      @relation("UserMessages")
  offers              Offer[]        @relation("UserOffers")
  PaymentBuyer        Payment[]      @relation("Buyer")
  PaymentSeller       Payment[]      @relation("Seller")
  products            Product[]
  sessions            Session[]

  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model LoginLog {
  id            String   @id @default(cuid())
  userId        String
  action        String
  ipAddress     String?
  userAgent     String?
  location      String?
  success       Boolean  @default(true)
  failureReason String?
  createdAt     DateTime @default(now())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("login_logs")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Category {
  id          String    @id @default(cuid())
  name        String    @unique
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  displayName String
  imageUrl    String?
  products    Product[]

  @@map("categories")
}

model Product {
  id            String         @id @default(cuid())
  title         String
  description   String?
  price         Float
  condition     String
  imagesUrl     String[]
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  categoryId    String
  status        String         @default("pending")
  ownerId       String
  city          String?
  delivery      String         @default("pickup")
  deliveryPrice Float?         @default(0)
  conversations Conversation[]
  favorites     Favorite[]
  payments      Payment[]
  category      Category       @relation(fields: [categoryId], references: [id])
  owner         User           @relation(fields: [ownerId], references: [id])

  @@map("products")
}

model Payment {
  id                    String            @id @default(cuid())
  stripePaymentIntentId String            @unique
  amount                Float
  currency              String            @default("eur")
  status                String            @default("pending")
  productId             String
  buyerId               String
  sellerId              String
  applicationFeeAmount  Float?
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  buyer                 User              @relation("Buyer", fields: [buyerId], references: [id])
  product               Product           @relation(fields: [productId], references: [id])
  seller                User              @relation("Seller", fields: [sellerId], references: [id])
  shipmentTracking      ShipmentTracking?
  shippingProof         ShippingProof?

  @@map("payments")
}

model ShipmentTracking {
  id                    String    @id @default(cuid())
  paymentId             String    @unique
  trackingNumber        String
  carrier               String    @default("colissimo")
  status                String    @default("pending")
  lastEventCode         String?
  lastEventLabel        String?
  lastEventDate         DateTime?
  estimatedDeliveryDate DateTime?
  actualDeliveryDate    DateTime?
  timeline              Json?
  events                Json?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  payment               Payment   @relation(fields: [paymentId], references: [id])

  @@map("shipment_tracking")
}

model ShippingProof {
  id          String    @id @default(cuid())
  paymentId   String    @unique
  proofType   String
  proofData   Json
  status      String    @default("pending_verification")
  submittedAt DateTime  @default(now())
  verifiedAt  DateTime?
  verifiedBy  String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  rejectedAt  DateTime?
  rejectedBy  String?
  payment     Payment   @relation(fields: [paymentId], references: [id])

  @@map("shipping_proof")
}

model Favorite {
  id        String   @id @default(cuid())
  userId    String
  productId String
  createdAt DateTime @default(now())
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, productId])
  @@map("favorites")
}

model Conversation {
  id        String    @id @default(cuid())
  productId String
  buyerId   String
  sellerId  String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  buyer     User      @relation("BuyerConversations", fields: [buyerId], references: [id], onDelete: Cascade)
  product   Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  seller    User      @relation("SellerConversations", fields: [sellerId], references: [id], onDelete: Cascade)
  messages  Message[]
  offers    Offer[]

  @@unique([productId, buyerId, sellerId])
  @@map("conversations")
}

model Message {
  id             String       @id @default(cuid())
  conversationId String
  senderId       String
  content        String
  messageType    String       @default("text")
  isRead         Boolean      @default(false)
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User         @relation("UserMessages", fields: [senderId], references: [id], onDelete: Cascade)
  offer          Offer?

  @@map("messages")
}

model Offer {
  id             String       @id @default(cuid())
  conversationId String
  messageId      String       @unique
  senderId       String
  amount         Float
  currency       String       @default("eur")
  status         String       @default("pending")
  offerMessage   String?
  originalPrice  Float
  expiresAt      DateTime?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  message        Message      @relation(fields: [messageId], references: [id], onDelete: Cascade)
  sender         User         @relation("UserOffers", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("offers")
}
